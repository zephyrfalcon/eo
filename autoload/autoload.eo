-- simple printing words

"autoload/docstrings.eo" include

{ 10 emit } "nl" def
{ 7 emit } "bel" def

{ print nl } "println" def

{ _ swap doc! } !_doc!

{ } "..." def  -- no-op

{ { } if } !when
"when ( condition block -- )
If condition is true, execute the block, otherwise do nothing." _doc!

-- do-times ( block n -- )
-- execute the given block n times.
{ !$n !$block
  $n 0 > {
    $block exec               -- execute the code
    $block $n 1 - do-times    -- recurse with n-1
  } when
} !do-times

-- each ( list block -- )
-- execute the code block for each item in the list. (i.e. each item in the
-- list is pushed, then the block is executed to do something with it.)
{ !$block !$list
  -- each-aux ( list block index -- )
  { !$index !$block !$list
    -- if index falls within the list, process that item
    $list length $index > {
      $list $index index                -- push list[index] onto the stack
      $block exec                       -- execute block
      $list $block $index 1 + each-aux  -- recurse
    } when
  } !each-aux
  $list $block 0 each-aux
} !each

-- ^ NOTE: technically we don't need the outer $block and $list...
-- but it's more readable this way.

-- map ( list block -- list' )
-- execute the code block for each item in the list. the code expects the item
-- to be on the stack when it's called, and in return leaves a new item on the
-- stack, which will be added to the result list.
{ !$block !$list
  -- map-aux (list block index acc -- )
  { !$acc !$index !$block !$list
    $list length $index >    -- if we're still in the list...
    { $list $index index        -- push list[index] on the stack
      $block exec               -- execute block
      !$item                    -- take the result and call it $item
      $acc $item add!           -- add it to the accumulator (in-place)
      $list $block $index 1 + $acc map-aux  -- recurse
    }
    { $acc }                 -- otherwise push $acc, the result list
    if
  } !map-aux
  $list $block 0 [ ] map-aux
} !map

-- while ( cond-block exec-block -- )
-- while cond-block evaluates to true (i.e. leaves 'true' on the stack),
-- execute exec-block.
{ !$exec-block !$cond-block
  $cond-block exec                        -- check condition
  { $exec-block exec                      -- if true, exec exec-block
    $cond-block $exec-block while } when  -- recurse
} !while

-- TODO: some kind of for loop... 
-- maybe something that works just with numbers (pushing a number in each round)
-- and maybe another one that takes a list and pushes index and item?
-- I need something like this to make string.join :)

-- clear ( ? -- )
-- clear the stack
{ { stack-empty? not } { drop } while 
} !clear

{ !$stuff
  "" !$result
  $stuff { ->string $result swap append !>$result } each
  $result
} !conc
"conc ( stuff -- string )
Join the string representations of all objects in `stuff` together, producing
a single string." _doc!

-- and* ( cond1 cond2 -- )
-- `and` with shortcut mechanism. cond1 and cond2 must be code blocks.
{ !$cond2 !$cond1
  $cond1 exec
  { $cond2 exec } { false } if
} !and*

-- or* ( cond1 cond2 -- )
-- `or` with shortcut mechanism. cond1 and cond2 must be code blocks.
{ !$cond2 !$cond1
  $cond1 exec
  { true } { $cond2 exec } if 
} !or*

-- for fun/completeness/because we can:
{ and not } !nand
{ or not } !nor

--
-- stack manipulation

-- dip ( block x -- x )
-- Take x, execute the code block, put x back.
-- Borrowed from Cat.
{ !$temp exec $temp } !dip

--
-- misc

-- empty? ( container -- bool )
-- Returns true if the given container (string, list, dict) is empty.
{ length 0 = } !empty?

-- is? ( a b -- bool )
-- Returns true if a and b refer to the same object internally.
--{ id swap id = } !is?
{ !$b !$a
  $a id $b id = } !is?
"is? ( a b -- bool )
Returns true if a and b refer to the same object internally." _doc!

-- create custom words from these type names
-- e.g. `int?` to check if something is an int, etc etc
--
[ "int" "string" "bool" "list" "dict" "u-word" "b-word" "module"
  "namespace" "block" "variable" "symbol" "regex" "null"
  ] !$TYPES
"All of Eo's built-in types." $TYPES\doc!

$TYPES { 
    !$type
    {   -- creating a new closure here, so we don't get namespace conflicts
        $type !$type
        -- create custom word
        -- e.g.: int? ( x -- bool )
        -- returns true if x is an int.
        $type "?" append !$wordname
        { type $type eq? } $wordname def  -- define the new word
        -- set custom doc string
        [ $wordname " ( x -- bool )" "\n"
          "Return true if x is of type " $type "." ] conc
        $wordname lookup-here swap doc!
        rootns $wordname $wordname lookup-here put!  -- stick in root namespace
    } exec
} each

{ !$x 
  $x u-word? $x b-word? or
} !word?

{ !$x
  $x string? $x list? or
} !sequence?

{ !$x
  [ "int" "string" "bool" "symbol" "null" "regex" ] $x type contains?
} !atom?

{ atom? not } !container?

------

{ !$tag !$obj
  $obj tags $tag contains?
} !has-tag?
"has-tag? ( obj tag - bool )
Return true if obj has the given tag." _doc!

------

{ /\s+/ split* } !split
"split ( s -- parts )
Split a string by whitespace." _doc!

