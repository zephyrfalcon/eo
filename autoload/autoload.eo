-- simple printing words

{ 10 emit } "nl" def
{ 7 emit } "bel" def

{ print nl } "println" def

-- when ( condition block -- )
-- if condition is true, execute the block, otherwise do nothing.
{ { } if } !when

-- do-times ( block n -- )
-- execute the given block n times.
{ !$n !$block
  $n 0 > {
    $block exec               -- execute the code
    $block $n 1 - do-times    -- recurse with n-1
  } when
} !do-times

-- each ( list block -- )
-- execute the code block for each item in the list. (i.e. each item in the
-- list is pushed, then the block is executed to do something with it.)
{ !$block !$list
  -- each-aux ( list block index -- )
  { !$index !$block !$list
    -- if index falls within the list, process that item
    $list length $index > {
      $list $index index                -- push list[index] onto the stack
      $block exec                       -- execute block
      $list $block $index 1 + each-aux  -- recurse
    } when
  } !each-aux
  $list $block 0 each-aux
} !each

-- ^ NOTE: technically we don't need the outer $block and $list...
-- but it's more readable this way.

-- map ( list block -- list' )
-- execute the code block for each item in the list. the code expects the item
-- to be on the stack when it's called, and in return leaves a new item on the
-- stack, which will be added to the result list.
{ !$block !$list
  -- map-aux (list block index acc -- )
  { !$list !$block !$index !$acc
    $list length $index >    -- if we're still in the list...
    { $list index index         -- push list[index] on the stack
      $block exec               -- execute block
      !$item                    -- take the result and call it $item
      $acc $item add            -- add it to the accumulator (in-place)
      $acc $index 1 + $block $list map-aux  -- recurse
    }
    { $acc }                 -- otherwise push $acc, the result list
    if
  } !map-aux
  $list $block 0 [ ] map-aux
} !map

