-- simple printing words

{ 10 emit } "nl" def
{ 7 emit } "bel" def

{ print nl } "println" def

-- when ( condition block -- )
-- if condition is true, execute the block, otherwise do nothing.
{ { } if } !when

-- do-times ( block n -- )
-- execute the given block n times.
{ !$n !$block
  $n 0 > {
    $block exec               -- execute the code
    $block $n 1 - do-times    -- recurse with n-1
  } when
} !do-times

-- each ( list block -- )
-- execute the code block for each item in the list. (i.e. each item in the
-- list is pushed, then the block is executed to do something with it.)
{ !$block !$list
  -- each-aux ( list block index -- )
  { !$index !$block !$list
    -- if index falls within the list, process that item
    $list length $index > {
      $list $index index                -- push list[index] onto the stack
      $block exec                       -- execute block
      $list $block $index 1 + each-aux  -- recurse
    } when
  } !each-aux
  $list $block 0 each-aux
} !each

-- ^ NOTE: technically we don't need the outer $block and $list...
-- but it's more readable this way.

-- map ( list block -- list' )
-- execute the code block for each item in the list. the code expects the item
-- to be on the stack when it's called, and in return leaves a new item on the
-- stack, which will be added to the result list.
{ !$block !$list
  -- map-aux (list block index acc -- )
  { !$acc !$index !$block !$list
    $list length $index >    -- if we're still in the list...
    { $list $index index        -- push list[index] on the stack
      $block exec               -- execute block
      !$item                    -- take the result and call it $item
      $acc $item add!           -- add it to the accumulator (in-place)
      $list $block $index 1 + $acc map-aux  -- recurse
    }
    { $acc }                 -- otherwise push $acc, the result list
    if
  } !map-aux
  $list $block 0 [ ] map-aux
} !map

-- while ( cond-block exec-block -- )
-- while cond-block evaluates to true (i.e. leaves 'true' on the stack),
-- execute exec-block.
{ !$exec-block !$cond-block
  $cond-block exec                        -- check condition
  { $exec-block exec                      -- if true, exec exec-block
    $cond-block $exec-block while } when  -- recurse
} !while

-- clear ( ? -- )
-- clear the stack
{ { stack-empty? not } { drop } while 
} !clear

--
-- stack manipulation

-- dip ( block x -- x )
-- Take x, execute the code block, put x back.
-- Borrowed from Cat.
{ !$temp exec $temp } !dip

--
-- misc

-- empty? ( container -- bool )
-- Returns true if the given container (string, list, dict) is empty.
{ length 0 = } !empty?

-- is? ( a b -- bool )
-- Returns true if a and b refer to the same object internally.
--{ id swap id = } !is?
{ !$b !$a
  $a id $b id = } !is?


